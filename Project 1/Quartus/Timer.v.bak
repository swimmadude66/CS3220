module TFlipFlop(
	input reset, 
	input clk, 
	output tOut
	);
	reg tOut = 0;
	always @(negedge reset or negedge clk) begin
		if (reset == 1'b0)
			tOut <= 0;
		else 
			tOut <= ~tOut;
	end
endmodule

module dec2_7seg(
	input [3:0] num, 
	output [6:0] display
	);
   assign display = 
	num == 0 ? ~7'b0111111 :
	num == 1 ? ~7'b0000110 :
	num == 2 ? ~7'b1011011 :
	num == 3 ? ~7'b1001111 :
	num == 4 ? ~7'b1100110 :
	num == 5 ? ~7'b1101101 :
	num == 6 ? ~7'b1111101 :
	num == 7 ? ~7'b0000111 :
	num == 8 ? ~7'b1111111 :
	num == 9 ? ~7'b1100111 :
	7'bxxxxxxx;   // Output is a don't care if illegal input
endmodule // dec2_7seg

module countSecond(
	input clkin, 
	input reset,
	input running,
	output second
	);
	
	reg[25:0] counter = 0;
	always @(negedge reset or negedge clkin) begin
		if (reset == 1b'0)
			counter <= 0;
		if (running == 1b'1)
			if (reg >= 50000000)
				assign second = 1b'0;
				counter <= 0;
			else
				assign second = 1b'1;
				counter <= counter + 1;
	end
endmodule

module countDown(
	input secondClock,
	output reg[6:0] minutes,
	output reg[5:0] seconds
	);
	
	
	
	always @(negedge secondClock) begin
		
	
	
endmodule


module Timer(
	input CLOCK_50, 
   input [9:0] SW,	
   input [3:0] KEY, 
   output [6:0] HEX0,
   output [6:0] HEX1,
   output [6:0] HEX2,
   output [6:0] HEX3,
   output [9:0] LEDR,
	output [2:0] LEDG
   );
	
	reg[6:0] minutes = 0;
	reg[5:0] seconds = 0;
	reg[2:0] X;
	reg[2:0] state = 3b'000;
	
	countSecond(CLOCK_50, CLOCK);
	TflipFlop(KEY[1], KEY[0], X[0]);
	TflipFlop(KEY[2], KEY[0], X[1]);
	TFlipFlop(CLOCK, KEY[0], X[2]);

	

	
	parameter SET_SEC = 3b'000, SET_MIN = 3b'001, START = 3b'010, STOP = 3b'011, FLASH = 3b'100;
	
	always @(negedge KEY[0] or negedge CLOCK_50) begin
		if (KEY[0] == 1b'0)
			state <= 3b'000;
		assign LEDG = state;
		case(state)
			SET_SEC:	if (X[0] == 1b'1)
							state <= SET_MIN;
						else if (X[1]  == 1b'1)
							state <= START;
						else
							if (SW[7:4] >= 5)
								seconds <= 50;
							else
								seconds <= SW[7:4]*10;
							if (SW[3:0] >= 9)
								seconds <= seconds+9;
							else
								seconds <= seconds + SW[3:0];				
			SET_MIN: if (X[1] == 1b'1)
							state <= START;
						else
							if (SW[7:4] >= 9)
								minutes <= 90;
							else
								minutes <= SW[7:4]*10;
							if (SW[3:0] >= 9)
								minutes <= minutes+9;
							else
								minutes <= minutes + SW[3:0];	
			START: 	if (X[1] == 1b'0)
							state <= STOP;
						else if (countDownDone ==  1b'1)
							state <= FLASH;
			STOP: 	if (X[1] == 1b'1)
							state <= START;
			FLASH: 	if (X[2] = 1b'1)
							assign LEDR[9:0] = 10b'1111111111;
						else
							assign LEDR[9:0] = 10b'0000000000;
		endcase
	end
	
	
	
	
	
	
	